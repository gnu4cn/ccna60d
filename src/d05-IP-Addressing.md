# 第 5 天 IP 地址分配

__IP Addressing__

___

Gitbook：[ccna60d.xfoss.com](https://ccna60d.xfoss.com/)


你可以在 https://github.com/gnu4cn/ccna60d 上 fork 本项目，并提交你的修正。


本书结合了学习技巧，包括阅读、复习、背书、测试以及 hands-on 实验。

> 本书译者用其业余时间完成本书的翻译工作，并将其公布到网上，以方便你对网络技术的学习掌握，为使译者更有动力改进翻译及完成剩下章节，你可以 [捐赠译者](https://github.com/gnu4cn/buy-me-a-coffee)。

___

## 第五天的任务

- 阅读今天的课文
- 复习昨天的课文
- 完成今天的实验
- 阅读 ICND1 记诵指南
- 花 15 分钟浏览 [subnetting.org](http://subnetting.org/) 网站

欢迎来到今天的学习，许多人都发现今天的内容是 CCNA 大纲中最难掌握的部分之一。为理解 CCNA 考试的 IP 分址， 我们必须涵盖**二进制运算及十六进制计数系统**（binary mathematics and the hexadecimal numbering system）、**地址类别**(classes of adresses)、**2 的指数**（powers of two）和**诸如零号子网（subnet zero）等规则**, 以及**广播地址与网络地址**，还有**用于计算子网地址和主机地址的公式**。

尽管有这些难点，但请无需担心；这都是有个过程的，而不是一蹴而就的，所以请跟上课文，就一定会发现我们会在本书中屡次回顾到这些概念。

今天会学到这些内容。

- IP 分址（采用二进制和十六进制），IP addressing (using binary and hexadecimal)
- IP 地址的使用，Using IP addresses
- 子网划分，Subnetting
- 简易子网划分，Easy subnetting
- 网络规划设计，Network design
- 采用 VLSM, Using VLSM
- 切分网络，Slicing down networks

本模块对应的是 CCNA 大纲要求的以下部分。

- 描述 IPv4 分址中使用私有和公共 IP 地址的做法和必要性，Describe the operationg and necessity of using private and public IP addresses for IPv4 addressing
- 找出采行 VLSM 和汇总技术，用以满足某个 LAN/WAN 环境中分址要求的恰当 IPv4 分址方案，Identify the appropriate IPv4 addressing scheme using VLSM and summarisation to satisfy addressing requirements in a LAN/WAN environment
- 对有关 IP 分址和主机配置有关的故障进行排除和修正， Troubleshoot and correct common problems associated with IP addressing and host configurations

思科已经将一些 VLSM 要求加入到 ICND1 和 ICND2 考试中了。而在 ICND2 考试中看起来考得更多一些，不过两个考试都需要你做好解答问题的准备。**在掌握 VLSM 前，你需要先理解 IP 分址和子网划分**。

## IP 分址，IP addressing

网络上的所有设备，都需要某种方法来将其识别为某台特定主机。早期网络简单地采用某种命名格式，同时服务器上维护着一张 MAC 地址与主机名称的映射图。服务器上的表格迅速增长，伴随其产生诸如一致性及准确性（consistency and accuracy）问题（如图 5.1）。IP 分址有效地解决了此问题。

!["设备命名表变得十分累赘"](images/0501.png)

### IP 版本 4, IP Version 4

IP 版本 4(IPv4）设计用于解决设备命名问题。IPv4 使用二进制在网络设备上应用一个地址。它使用 `32` 位二进制数，分成每 `8` 位的 `4` 组。下面是二进制的 IPv4 地址的一个实例。

`11000000.10100011.11110000.10101011`

以十进制来看，就是。

`192.168.240.171`

每一个二进制位表示一个十进制数，你可以在相应的列中，依据该列是`1`还是`0`, 而使用或不用其对应的十进制数。下面是 `8`个列。

| `128` | `64` | `32` | `16` | `8` | `4` | `2` | `1` |
| -- | -- | -- | -- | -- | -- | -- | -- |
| `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` |

从上表中可以看到，仅有前两个十进制数被用到（下方有 `1` 的两个），这就产生出数值 `128+64=192`。

### 二进制，Binary

为理解 IP 寻址(IP addressing)的工作原理, 你需要理解二进制计数法（binary mathematics）。计算机及网络设备是不理解十进制的。我们使用 `10` 进制，是由于它是一种使用了 `10` 个数字的计数系统，由很久很久以前的穴居人类在意识到他有 `10` 个手指头，可以在有恐龙经过洞口时用来数恐龙时发明的。

计算机和网络设备只明白电信号。而电信号不是开就是关，唯一可用的计数系统就是二进制。二进制只用到两个数字，`0` 和 `1`。`0` 表示线路上没有电脉冲，而 `1` 就表示线路上有一个脉冲。

使用二进制值，可以生成任何数字。加的二进制数值越多，得到的数量就越大。所加入的每个二进制值，其下一个数字都要是它的两倍（也就是，`1` 到`2`到`4`到`8`到`16`,以致无穷），从右往左。如有两位，最多可计到`3`。只需将`0`或`1`放入到表格的列中，以确定是否要使用该列的值。

我们从仅有两位的二进制数开始。

| `2` | `1` |
| -- | -- |
| `0` | `0` |

`0+0=0`

| `2` | `1` |
| -- | -- |
| `0` | `1` |

`0+1=1`

| `2` | `1` |
| -- | -- |
| `1` | `0` |

`2+0=2`

| `2` | `1` |
| -- | -- |
| `1` | `1` |

`2+1=3`

如你使用`8`位二进制数（也就是一个八位字节），你能取得如何从`0`到`255`之间的数值。而你可以看到，这些位数自右往左移动。

| `128` | `64` | `32` | `16` | `8` | `4` | `2` | `1` |
| -- | -- | -- | -- | -- | -- | -- | -- |
|   |   |   |   |   |   |   |   |   |

在往各列中填入`0`时，就有了十进制的`0`。

| `128` | `64` | `32` | `16` | `8` | `4` | `2` | `1` |
| -- | -- | -- | -- | -- | -- | -- | -- |
| `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |

而将 1 填入各列，就得到了十进制的`255`.

| `128` | `64` | `32` | `16` | `8` | `4` | `2` | `1` |
| -- | -- | -- | -- | -- | -- | -- | -- |
| `1` | `1` | `1` | `1` | `1` | `1` | `1` | `1` |

不信吗？

`128+64+32+16+8+4+2+1=255`

如此，逻辑使然，你实际上可以通过将`0`或`1`放入不同的列，而生成`0`到`255`之间的任何数值。比如。

| `128` | `64` | `32` | `16` | `8` | `4` | `2` | `1` |
| -- | -- | -- | -- | -- | -- | -- | -- |
| `0` | `0` | `1` | `0` | `1` | `1` | `0` | `0` |

`32+8+4=44`

**上面的基础知识，是 IP 寻址和子网划分的基础。** 下面的表5.1对你现在所掌握的进行了总结。这些值可用作任意子网掩码，所以请留心一下。

**表 5.1 -- 二进制值，Binary Values**

| 二进制，Binary | 十进制，Decimal |
| -- | -- |
| `1000 0000` | `128` |
| `1100 0000` | `192` |
| `1110 0000` | `224` |
| `1111 0000` | `240` |
| `1111 1000` | `248` |
| `1111 1100` | `252` |
| `1111 1110` | `254` |
| `1111 1111` | `255` |

构造一些你自己的二进制数，确保你完全地掌握了这个概念。

### 十六进制，Hexadecimal

十六进制（ hex ）是另一个替代的计数系统。比起以 2 或 10 来计数，它用到 16 个数字或字母。十六进制从 0 开始知道 F，如下面所示。
`0	1	2	3	4	5	6	7	8	9	A	B	C	D	E	F`

每位十六进制数实际上代表的是`4`位二进制数，如表5.2所示。

**表5.2 -- 十进制、十六进制和二进制位数，Decimal, Hex, and Binary Digits**

<table>
    <tr>
        <th>十进制，Decimal</th><td>`0`</td><td>`1`</td><td>`2`</td><td>`3`</td><td>`4`</td><td>`5`</td><td>`6`</td><td>`7`</td>
    </tr>
    <tr>
        <th>十六进制，Hex</th><td>`0`</td><td>`1`</td><td>`2`</td><td>`3`</td><td>`4`</td><td>`5`</td><td>`6`</td><td>`7`</td>
    </tr>
    <tr>
        <th>二进制，Binary</th><td>`0000`</td><td>`0001`</td><td>`0010`</td><td>`0011`</td><td>`0100`</td><td>`0101`</td><td>`0110`</td><td>`0111`</td>
    </tr>
    <tr>
        <th>十进制，Decimal</th><td>`8`</td><td>`9`</td><td>`10`</td><td>`11`</td><td>`12`</td><td>`13`</td><td>`14`</td><td>`15`</td>
    </tr>
    <tr>
        <th>十六进制，Hex</th><td>`8`</td><td>`9`</td><td>`A`</td><td>`B`</td><td>`C`</td><td>`D`</td><td>`E`</td><td>`F`</td>
    </tr>
    <tr>
        <th>二进制，Binary</th><td>`1000`</td><td>`1001`</td><td>`1010`</td><td>`1011`</td><td>`1100`</td><td>`1101`</td><td>`1110`</td><td>`1111`</td>
    </tr>
</table>

将二进制转换成十六进制及十进制，是相当简单的，如表5.3所示。

**表5.3 -- 二进制到十六进制、十进制的转换**

<table>
    <tr>
        <th>十进制，Decimal</th><td>`13`</td><td>`6`</td><td>`2`</td><td>`12`</td>
    </tr>
    <tr>
        <th> 十六进制, Hex</th><td>`D`</td><td>`6`</td><td>`2`</td><td>`C`</td>
    </tr>
    <tr>
        <th> 二进制，Binary</th><td>`1101`</td><td>`0110`</td><td>`0010`</td><td>`1100`</td>
    </tr>
</table>

相对于二进制，十六进制对人类来讲更易于掌握，其又能够近似于二进制那样为计算机和网络设备所使用。任何的数都可由十六进制构造出来，这点跟二进制和十进制一样；如下面的例子一样，只需计算`16`的乘积。

```console
1 x 16 = 16
16 x 16 = 256
16 x 16 x 16 =4096
```

如此等等。

<table>
<tr><th>十六进制，Hex</th><td>`4096`</td><td>`256`</td><td>`16`</td><td>`1`</td></tr>
<tr><th></th><td></td><td></td><td>`1`</td><td>`A`</td></tr>
</table>

在以十六进制数数时，就要像这样，`0 1 2 3 4 5 6 7 8 9 A B C D E F 10 11 12 13 14 15 16 17 18 19 1A 1B 1F 1E 1F 20 21 22`, 等等， 一直到无穷。比如上面的 `1A`， 就是在 `1` 的列上有个 `A`，在 `16` 的列上有个 `1`, 那么： `1A = 10 + 16 = 26`。

在将二进制转换成十六进制时，如你将`8`位的二进制数分为`4`位一组的两组，就变得相当容易了。如此一来，二进制数 `11110011` 就成了 `1111 0011`。`1111` 就是 `8 + 4 + 2 + 1 = 15`, 而 `0011` 就是 `2 + 1 = 3`。`15` 就是十六进制的 `F`，`3` 就是 `3`, 所以答案就是 `F3`。你可以通过表 5.2 来验证这点。


而十六进制到二进制的转换，其过程与此一致。比如，`7C` 可分解为 `7`, 也就是二进制的 `0111`, 及 `C` （十进制的 `12`）, 它是二进制的 `1100`。答案就是 `01111100`。


### 转换练习，Converting Exercise

这里有些你可以试做的例题。在进行计算前，先写出上面的表格（也就是显示 `1` 这列，接着是 `16` 这列，再是 `256` 列，等等）。

1. 将`1111`转换成十六进制和十进制。
2. 将`11010`转换成十六进制和十进制。
3. 将`10000`转换成十六进制和十进制。
4. 将`20`转换成二进制和十六进制。
5. 将`32`转换成二进制和十六进制。
6. 将`101`转换成二进制和十六进制。
7. 将`A6`从十六进制转换成十进制和二进制。
8. 将`15`从十六进制转换成十进制和二进制。
9. 将`B5`从十六进制转换成十进制和二进制。

在考试中，写出表5.2，有助于你完成三种进制之间的转换。

IP 地址分配的规则有：**网络上的每个地址，都要是其主机所唯一的（也就是说 IP 地址不能共用）**。**一些地址不能用作主机地址**。这将在后面的章节涉及，但在这里，**要知道为整个网络保留的那个地址，也就是广播地址，以及保留用于测试目的的那些地址，此外，有三组保留的用于内部网络的地址（此举正是为节省 IP 地址），是不能使用的**。

由于网络规模的迅速增长，每个 IP 地址就必须与一个子网掩码配合使用。子网掩码是要告诉网络设备，怎样来使用 IP 地址中的数字。而此举的用意，就是可以借用地址中的主机位，将网络切割为更小的子网。

这里有个带子网掩码的 IP 地址实例，`192.168.1.1 255.255.255.0`。

## 地址类别，Address Classes

你是要掌握这个的，却没有掌握吧。我知道我是不能帮你太多的，但地址类别实际上是明显过时的了，所以作为一名思科工程师，当你在见到这种老规矩时，总是会感到迷惑，却还要把这些规则用到网络设计中去。

现在我们仍然将 IP 地址组别叫做类（ classes ），但随着子网掩码和变长子网掩码（Variable-Length Subnet Masking， VLSM ）概念的引入，地址类实际上已不再适用于网络设计了。掌握地址类别仍然是有用的，因为类别的不同可以让我们清楚，在小型网络（子网）中，可以使用哪些 IP 地址，而不能使用另一些。

在 IPv4 刚推出时，其地址就分成了不同类别。不同地址类别依其需求而分配给各家机构。机构越大，地址类别就越大。不同地址类别又指定了相应字母，从`A`到`E`。`A` 类地址保留给最大的一些网络。而`A`类地址的前`8`个二进制位可以是从`1`到`126`的数。此举的原因在于其前 8 位的首位必须是`0`。而当前`8`位中有了第一位的`0`时，那么剩下的值就只能是`1`到`126`了。也就是下面这样。

`0000 0001 = 1`

`0111 1111 = 127`

**在网络中，是不可以有全`0`地址的**。在加入其它三个`8`位二进制数后，就可以看到`A`类地址的全貌了。就像下面的那样。

`10.1.1.1`

`120.2.3.4`

`126.200.133.1`

这些都是`A`类地址，因为它们都是在`1`到`126`的范围内。`127`不是 IP 地址所允许的数字；**`127.0.0.1`实际上用于在设备上测试TCP/IP是否正常**。

`B`类地址前`8`位二进制数的头两位则必须是 10 。这就意味着前`8`位二进制数值处于`128`到`191`之间，也就是下面这样。

`1000 0000 = 128`

`1011 1111 = 191`

对于`C`类地址来说，前`8`位二进制数的头三位必需为`110`, 那么地址就在`192`到`223`之间，也就是下面这样。

`1100 0000 = 192`

`1101 1111 = 223`

`D`类地址用于多播（multicasting, directed broadcasting, 受导向的广播），而`E`类地址则仅用于实验用途。

### 子网掩码初步，Subnet Mask Primer

先前提到过 IP 地址用于区分网络的部分以及用于区分网络上主机地址的部分。子网掩码的作用就是确立此两部分。难点就在于并不总是能仅仅看一眼子网掩码，就能知道 IP 地址的网络部分和主机部分。这需要实践，且对于那些更难的地址，你就必须要动手计算出来（或是使用某个子网计算程序来作弊）。

就算未曾将网络划分成更小的部分，你仍需采用为用到的每个地址应用一个子网掩码。而上面提到的地址类，它们都有一个默认的子网掩码，如同下面这样。

`A`类地址 = `255.0.0.0`
`B`类地址 = `255.255.0.0`
`C`类地址 = `255.255.255.0`

在二进制位开启时，网络就知道该位是用作网络地址，而不是网络上的主机地址，如下表所示。

| - | - | - | - |
| -- | -- | -- | -- |
| `192` | `168` | `12` | `2` |
| `255` | `255` | `255` | `0` |
| 网络位 | 网络位 | 网络位 | 主机位 |

上面的地址表明 `192.168.12` 是网络地址，`2` 是该网络上的一台主机。再者，任何以`192.168.12`开头的 IP 地址，都是在同一网络上的。而在看看前`8`位的数字，以及该默认的子网掩码，就知道这是一个`C`类网络。

请记住早前提到的规则：主机所不能使用的那些网络号，那么下面的这些网络号就不能为设备所使用了。

`10.0.0.0`

`174.12.0.0`

`192.168.2.0`

另一规则是你不能使用各个网络或子网上的广播地址。某广播地址是前往网络上所有设备，那么，逻辑上就不能为设备所使用了。广播地址就是将所有主机位开启的地址，像下面这样。

`10.255.255.255`

`192.168.1.255`

在上面的例子中，主机部分的所有二进制位都是打开的。

## IP地址的使用，Using IP Addresses

接下来就是 IP 地址使用实务了，在这里我们要探讨一下哪些可以使用，哪些又不能使用。

你知道在过去二十年中计算机的使用曾有一个大暴发。个人计算机曾是十分昂贵的物品，以致只有少数人才买得起；因此只有那些有钱的机构才会保有使用。今天，几乎每个家庭都有那么一台或几台计算机了。

问题就在于 IPv4 实在仅有少数设备投入使用时发明的，且那时未曾预期到会有如此大的变化。在地址分配时，就意识到了如今的增长率，我们将很快用完可用的地址。

### 私有 IP 地址，Private IP Addresses

几种解决方案之一就是保留一些类别的地址给那些要用的人，同时这些地址不再国际互联网上使用。这些地址就是私有 IP 地址，而此方案是由 `1918` 和 `4193` 两个 RFC 所构建的。

下面就是私有地址的几个范围。

`10.x.x.x` -- 以 10 开头的地址

`172.16.x.x` 到 `172.31.x.x` -- `172.16`到`172.31`中的那些地址

`192.168.x.x` -- 以`192.168`开头的那些地址

## 子网划分，Subnetting

子网划分让我们可以从一般用于网络上的主机位的那些 IP 地址位中，进行借用。此时就可以自较大的网络空间，划出一些更小的网络了，这些较小的网络，就被成为子网（subnetworks, 简写为 subnets ）。

在对三类可用地址应用默认子网掩码时，你会发现不能用于划分子网的地址部分，如下面的表格所示。

| - | - | - | - |
| -- | -- | -- | -- |
| `A`类 -- `255` | `0` | `0` | `0` |
| 不能使用 | 可以使用 | 可以使用 | 可以使用 |
| B类 -- `255` | `255` | `0` | `0` |
| 不能使用 | 不能使用 | 可以使用 | 可以使用 |
| C类 -- `255` | `255` | `255` | `255` |
| 不能使用 | 不能使用 | 不能使用 | 可以使用 |

比如，如你将某个 C 类网络以默认子网掩码方式使用，那么就是这样的。

<table>
<tr><th>IP地址</th><td>`192`</td><td>`168`</td><td>`1`</td><td>`0`</td></tr>
<tr><th>子网掩码</th><td>`255`</td><td>`255`</td><td>`255`</td><td>`0`</td></tr>
<tr><th>二进制形式</th><td>`1111 1111`</td><td>`1111 1111`</td><td>`1111 1111`</td><td>0000 0000</td><td>
</table>

在从后`8`位二进制数借用`2`位后，就会得到下面的子网，每个子网有`62`台主机。

| 网络号 | 网络号 | 网络号 | 子网号 | 主机 | 广播地址 |
| -- | -- | -- | -- | -- | -- |
| `192` | `168` | `1` | `0` | `1-62` | `63` |
| `192` | `168` | `1` | `64` | `65-126` | `127` |
| `192` | `168` | `1` | `128` | `129-190` | `191` |
| `192` | `168` | `1` | `192` | `193-254` | `255` |

在较大的网络中，你原来可以使用到`1`至`254`的主机号，这样看来，在进行了子网划分后，可用的主机号减少了，但得到的是更多的网络数。下面的表说明了`4`个子网是怎么得来的。

| `128` | `64` | `32` | `16` | `8` | `4` | `2` | `1` | 子网号 |
| -- | -- | -- | -- | -- | -- | -- | -- | -- |
| `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |
| `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `64` |
| `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `128` |
| `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `192` |

考虑二进制数学，你能发现对主机位的头两位使用，就可以使用`00`、`01`、`10`和`11`四种组合，在将其写出后，在子网列就得到子网`0`、`64`、`128`以及`192`四个子网号。为更明了的表示，头两列的子网号标记为灰色，而剩下的`6`位，就用作每个子网的主机号。

如你现在觉得很绕，这是正常的。我恐怕你会有点时间来适应的。

### 简易子网划分，Easy Subnetting

在考试时，或是在现场网络上进行故障排除时，你会希望快速精确地得到结果。那么我就给出一直简易子网划分方法，是我的 Kindle 电子书“子网划分秘密/Subnetting Secrets”的内容。你无需通读该书，这里就要相关内容。

我所创建的网站 [www.subnetting.org](http://www.subnetting.org)是一个非常有用的资源，有着一些有个子网划分和网络设计的习题。

### 无类域间路由，Classless Inter-Domain Routing, CIDR

无类域间路由是由互联网工程任务组（Internet Engineering Task Force, IETF）创建的，作为一种分配 IP 地址块及路由 IP 数据包的方法。这里要考察的 CIDR 主要特性，就是以斜杠（/）地址表示法（slash address notation）, 来表示子网掩码。因为这可以节省时间，所以该方法是较为重要的，在现实中也要用到，而除此之外，还会考到有关 CIDR 地址的问题。

有了 CIDR ，你要将所用到的二进制位的树木写下来，以取代之前用到完整子网掩码。比如对于`255.255.0.0`, 它用到了两个`8`位二进制数，那么就会用`/16`来表示。又比如`255.255.240.0`, 使用到 8 + 8 + 4 个二进制位，就是`/20`了。

在网际互联是对子网掩码或是网络掩码的叫法，应该读作”斜杠 16 “或”斜杠 20 “, 如此来与同事配合工作，而他们就能明白你说的是一个 CIDR 掩码了。

### 子网划分秘笈，The Subnetting Secrects Chart

此秘笈将从几个星期的子网划分纠葛中将你拯救。我（原作者）的这本秘笈，已为全世界上万的 CCNA 及 CCNP 学员所采用，他们用其通过考试，或是在工作面试中获得成功。

多年前，在我在为 CCNA 考试学习时偶然发现这个简易方法前，学员们都不得不将网络地址的二进制形式写下来，或是要进行痛苦地计算，来得到正确答案。

要写出秘笈所要用到的图表，你需要一只铅笔和一张纸。在考试中，因为只会给你一块白板用于计算，你需要凭记忆将该图表画出来。而在工作面试中，你是可以使用铅笔和白纸的。

在白纸的顶部右边，写下`1`, 再往左依次写下乘以`2`的结果，分别是`2`、`4`、`8`，并一直乘以`2`, 直到数字`128`。那么就有了一组 8 位二进制数了。

| - | - | - | - | - | - | - | - |
| -- | -- | -- | -- | -- | -- | -- | -- |
| `128` | `64` | `32` | `16` | `8` | `4` | `2` | `1` |


在`128`这个数往下，写下第一个格子里的数的和（`128`的那个格子）。接着再写下到第二个格子里的数的和（`64`），接着到第三个（`32`）, 直到将所有`8`个格子的数加完为止。

| - |
| -- |
| `128` |
| `192` |
| `224` |
| `240` |
| `248` |
| `252` |
| `254` |
| `255` |

在将两部分放在一起后，就得到了秘笈图表的上半部分了。

| 二进制位数 | `128` | `64` | `32` | `16` | `8` | `4` | `2` | `1` |
| -- | -- | -- | -- | -- | -- | -- | -- | -- |
| 子网号 |  |  |  |  |  |  |  |  |
| `128` |  |  |  |  |  |  |  |  |
| `192` |  |  |  |  |  |  |  |  |
| `224` |  |  |  |  |  |  |  |  |
| `240` |  |  |  |  |  |  |  |  |
| `248` |  |  |  |  |  |  |  |  |
| `252` |  |  |  |  |  |  |  |  |
| `254` |  |  |  |  |  |  |  |  |
| `255` |  |  |  |  |  |  |  |  |

顶上的行表示子网掩增量，而左侧的列则表示子网掩码。使用这个图表后，你就可以在数秒内回答任何子网划分的问题了。而那个可指明任何网络设计问题，诸如在以某子网掩码`X`划分网络时，可得到多少个子网和主机这样的问题，的答案的图表部分，只需加入"`2`的幂"就行了。

其中一列会是"`2`的幂"， 另一列就是"`2`的幂减去`2`"。减去的`2`的意思是要除去不能使用的两个地址，一个是网络号，另一个是广播地址。以数字`2`开始，乘以`2`, 一直到回答问题所需要的大小为止。

| 二进制位数 | `128` | `64` | `32` | `16` | `8` | `4` | `2` | `1` |
| -- | -- | -- | -- | -- | -- | -- | -- | -- |
| 子网号 |  |  |  |  |  |  |  |  |
| `128` |  |  |  |  |  |  |  |  |
| `192` |  |  |  |  |  |  |  |  |
| `224` |  |  |  |  |  |  |  |  |
| `240` |  |  |为计算出主机所在的子网是哪一个 |  |  |  |  |  |
| `248` |  |  |  |  |  |  |  |  |
| `252` |  |  |  |  |  |  |  |  |
| `254` |  |  |  |  |  |  |  |  |
| `255` |  |  |  |  |  |  |  |  |
|  | 子网数 | 主机数-`2` |  |  |  |  |  |  |
| `2` |  |  | 为计算出有多少个子网以及每个子网有多少台主机 |  |  |  |  |  |
| `4` |  |  |  |  |  |  |  |  |
| `8` |  |  |  |  |  |  |  |  |
| `16` |  |  |  |  |  |  |  |  |
| `32` |  |  |  |  |  |  |  |  |
| `64` |  |  |  |  |  |  |  |  |

通过直接切入一个考试问题，可以更好的学习到子网划分。

`192.168.100.100/26` 是在那个子网中？

那么，你知道这是一个 C 类地址，而 C 类地址的默认掩码是 24 个二进制位，或写着`255.255.255.0`。而这里是 26 位，所以有两位被借用来产生子网了。我们只需简单地在上面的秘笈图表中的顶上一行，从左往右勾上两个位置。这样就揭示出子网个数了。接着在子网号那列往下勾上两个位置，来揭示出所存在的子网掩码。

| 二进制位数 | `128` | `64` | `32` | `16` | `8` | `4` | `2` | `1` |
| -- | -- | -- | -- | -- | -- | -- | -- | -- |
| 子网号 | 〇 | 〇 |  |  |  |  |  |  |
| `128` | 〇 |  |  |  |  |  |  |  |
| `192` | 〇 |  |  |  |  |  |  |  |
| `224` |  |  |  |  |  |  |  |  |
| `240` |  |  |  |  |  |  |  |  |
| `248` |  |  |  |  |  |  |  |  |
| `252` |  |  |  |  |  |  |  |  |
| `254` |  |  |  |  |  |  |  |  |
| `255` |  |  |  |  |  |  |  |  |
|  | 子网数 | 主机数-`2` |  |  |  |  |  |  |
| `2` |  |  |  |  |  |  |  |  |
| `4` |  |  |  |  |  |  |  |  |
| `8` |  |  |  |  |  |  |  |  |
| `16` |  |  |  |  |  |  |  |  |
| `32` |  |  |  |  |  |  |  |  |
| `64` |  |  |  |  |  |  |  |  |

现在所知道的有两件事，子网号以`64`递增（可将`0`用作首个子网号），同时子网掩码`/26`以`192`结束，那么，该结束子网掩码的完整形式为`255.255.255.192`。

`192.168.100.0` 是第一个子网
`192.168.100.64` 是第二个子网
`192.168.100.128` 是第三个子网
`192.168.100.192` 是第四个子网

是不可以比实际的子网号有更多的了，也就是这里的`192`。不过记住问题是要你找出主机`100`。我们轻易地就看出子网`64`就是主机`100`所在的子网，因为下一子网是`128`, 那太高了。

下面为了知识的完整性，我加入了主机地址及广播地址。去下一子网号再减去1, 就可以很快算出广播地址来。

| 子网 | 首台主机 | 最后的主机 | 广播地址 |
| -- | -- | -- | -- |
| `192.168.100.0` | `192.168.100.1` | `192.168.100.62` | `192.168.100.63` |
| `192.168.100.64` | `192.168.100.65` | `192.168.100.126` | `192.168.100.127` |
| `192.168.100.128` | `192.168.100.129` | `192.168.100.190` | `192.168.100.191` |
| `192.168.100.192` | `192.168.100.193` | `192.168.100.254` | `192.168.100.255` |

考虑到 IP 地址是`0`到`255`之间的任何值。（不翻译了，太简单！）


